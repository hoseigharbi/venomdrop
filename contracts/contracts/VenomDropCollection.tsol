pragma ever-solidity >=0.62.0;
pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "./interfaces/IVenomDropCollection.tsol";
import "@itgold/everscale-tip/contracts/TIP4_1/TIP4_1Collection.sol";
import "./Nft.tsol";
import "./utils/Ownable.tsol";
import "./libraries/Errors.tsol";

contract VenomDropCollection is TIP4_1Collection, Ownable {
  uint static _id;
  address private _owner;
  uint private _maxSupply;
  MintStage[] private _mintStages;

  constructor(TvmCell codeNft, address owner) public TIP4_1Collection(codeNft) {
    tvm.accept();
    _transferOwnership(owner);
  }

  // UTILS

  /**
   * @notice Validate Mint Stages.
   *         The mint stages should not have date overlap.
   *
   * @param mintStages the list of mint stages
   */
  function _validateMintStages(MintStage[] mintStages) pure internal {
    uint256 numStages = mintStages.length;
    for (uint256 i = 0; i < numStages; i++) {
        MintStage mintStage = mintStages[i];
        
        require(mintStage.startTime > 0, Errors.START_DATE_SHOULD_BE_GREATER_THAN_ZERO);
        
        bool isLast = i == mintStages.length - 1;
        if (!isLast && mintStage.endTime == 0) {
          revert(Errors.ONLY_LAST_STAGE_CAN_HAVE_END_DATE_EQUAL_ZERO);
        }
        
        for (uint256 j = i + 1; j < numStages; j++) {
            MintStage nextStage = mintStages[j];
            require(nextStage.startTime > mintStage.endTime, Errors.INVALID_STAGES_TIMELINE);
        }
    }
  }

  function _getCurrentMintStage() private view returns (MintStage mintStage) {
    uint256 numStages = _mintStages.length;
    for (uint256 i = 0; i < numStages; i++) {
      MintStage stage = _mintStages[i];
      if(block.timestamp > stage.startTime && block.timestamp < stage.endTime) {
        return stage;
      }
    }
    revert(Errors.THERE_IS_NO_CURRENT_STAGE);
  }

  // PRIVATE FUNCTIONS

  function _mintNft() private {
    require(msg.value > 0.4 ever, 101);
    tvm.rawReserve(0, 4);

    uint256 id = uint256(_totalSupply);
    _totalSupply++;

    TvmCell codeNft = _buildNftCode(address(this));
    TvmCell stateNft = tvm.buildStateInit({ contr: Nft, varInit: { _id: id }, code: codeNft });
    new Nft{ stateInit: stateNft, value: 0, flag: 128 }(msg.sender, msg.sender, 0.3 ever);
  }

  // PUBLIC FUNCTIONS

  /**
   * @notice set the max supply for the collection
   */
  function setMaxSupply(uint maxSupply) public onlyOwner {
    _maxSupply = maxSupply;
  }

  /**
   * @notice Set all mint stages for the collection
   */
  function setMintStages(MintStage[] mintStages) public onlyOwner {
    _validateMintStages(mintStages);
    _mintStages = mintStages;
  }

  /**
   * @notice Mint NFT
   */
  function mint() public {
    MintStage mintStage = _getCurrentMintStage();
    _mintNft();
  }

  // PUBLIC VIEWS

  /**
   * @notice get the max supply for the collection
   */
  function getMaxSupply() public view returns (uint256 maxSupply) {
    return _maxSupply;
  }

  /**
   * @notice get the mint stages for the collection
   */
  function getMintStages() public view returns (MintStage[] mintStages) {
    return _mintStages;
  }
}
